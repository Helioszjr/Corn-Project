---
title: "PROJETO MILHO"
author: "Helio Junior"
date: '2022-04-07'
output: html_document
editor_options: 
  chunk_output_type: console
---

# AULA 4

## Introdução ao R/qtl

O pacote R é uma ferramenta importante para quem trabalha com linkage e mapeamento QTL.

Para usar, precisará instalá-lo primeiro. Podemos fazer isso usando a função. Em seguida, podemos carregar o pacote em R usando a função: qtlinstall.packageslibrary


### Análise de ligação I: segregação de marcadores, cálculo da fração de recombinação dois-pontos, e formação dos grupos de ligação.

```{r}
library(qtl)
```

## Dados do milho

```{r}
population_Z006 <- read.cross(format="csv", file="population_z006.csv", genotypes=c("0","1","2"), crosstype = "riself")
```

Para executar a análise com os dados do mouse, precisamos carregar o conjunto de dados usando uma função específica do pacote chamado . Também podemos usar funções associadas, como e inspecionar os dados com mais cuidado:qtlread.crosssummarygeno.image

#### -DADOS:
#####	 185  individuos
#####	 1106  marcadores
#####	 29  fenótipos

```{r}
summary(population_Z006)
```

##  No. individuals:    185 

##  No. phenotypes:     29 
    Percent phenotyped: 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 

##  No. chromosomes:    1 
##        Autosomes:    0 

##  Total markers:      1106 
##  No. markers:        1106 
##  Percent genotyped:  92.1 
##  Genotypes (%):      AA:48.4  BB:51.6 

```{r}
geno.image(population_Z006)
```

Agora, calculamos os testes qui-quadrado para ver o quão bem os dados se encaixam na segregação esperada de 1:2:1:

```{r}
gt.population_z006 <- geno.table(population_Z006)
gt.population_z006
```

```{r}
table(gt.population_z006$P.value < 0.05)
```

## FALSE  TRUE 
## 947   159

```{r}
table(gt.population_z006$P.value < 0.05/totmar(population_Z006))
```

## FALSE
## 1091    

A partir da correção bonferroni dos testes de segregação realizados, notamos que não há segregação distorcida entre os 14 marcadores.

Agora, podemos estimar frações de recombinação usando a função e usar a função para ver os resultados: est.rfplotRF

E, finalmente, estimamos as frações de recombinação em pares:

```{r}
population_Z006 <- est.rf(population_Z006)
plotRF(population_Z006, col.scheme = "redblue")
```

Este mapa de calor apresenta tanto o rr estimativas (acima de diagonal) e escores de LOD (abaixo da diagonal).

Uma vez que as frações de recombinação de pairwise tenham sido computadas, podemos tentar ver se esses marcadores estão ligados ou não. Para fazê-lo, assumimos que os marcadores estão ligados se r<0,38r<0,38 e LOD>6LOD>3:

```{r}
population_Z006 <- formLinkageGroups(population_Z006, max.rf=0.38, min.lod=6)
table(population_Z006[,2])
```

## 1   2   3   4   5   6    7   8   9   10 
## 175 139 130 127 111 106  85  78  78  77 

A partir da função, notamos que apenas 10 grupo é formado, o que significa que todos os 1000 marcadores do conjunto de dados do milho são do mesmo cromossomo.table






# AULA 5

## Análise de ligação II: ordenação dos marcadores

Precisamos carregar o conjunto de dados usando a função:read.cross

```{r}
population_Z006 <- read.cross(format="csv", file="population_z006.csv", genotypes=c("0","1","2"), crosstype = "riself")
```

Antes de fazer qualquer pedido, precisamos calcular as frequências de recombinação de dois pontos (usando ):est.rf

```{r}
population_Z006 <- est.rf(population_Z006)
```

E, com base nas frequências de recombinação de dois pontos, pedimos ao software que procure marcadores no mesmo grupo de linkagem:

```{r}
population_Z006 <- formLinkageGroups(population_Z006, max.rf = 0.38, min.lod=6, reorgMarkers=TRUE) 
                                
```

Agora, usamos a função para obter um pedido para os marcadores em cada grupo de linkage (temos apenas um grupo de linkage como identificado em nossa última classe). Primeiro, com:orderMarkersripple = FALSE

```{r}
population_Z006 <- orderMarkers(population_Z006, chr = 1, use.ripple = FALSE, map.function="kosambi")
plotRF(population_Z006, col.scheme = "redblue", mark.diagonal = TRUE)
```


```{r}
population_Z006 <- orderMarkers(population_Z006, chr = 2, use.ripple = FALSE, map.function="kosambi")
plotRF(population_Z006, col.scheme = "redblue", mark.diagonal = TRUE)
```


```{r}
population_Z006 <- orderMarkers(population_Z006, chr = 3, use.ripple = FALSE, map.function="kosambi")
plotRF(population_Z006, col.scheme = "redblue", mark.diagonal = TRUE)
```


```{r}
population_Z006 <- orderMarkers(population_Z006, chr = 4, use.ripple = FALSE, map.function="kosambi")
plotRF(population_Z006, col.scheme = "redblue", mark.diagonal = TRUE)
```


```{r}
population_Z006 <- orderMarkers(population_Z006, chr = 5, use.ripple = FALSE, map.function="kosambi")
plotRF(population_Z006, col.scheme = "redblue", mark.diagonal = TRUE)
```


```{r}
population_Z006 <- orderMarkers(population_Z006, chr = 6, use.ripple = FALSE, map.function="kosambi")
plotRF(population_Z006, col.scheme = "redblue", mark.diagonal = TRUE)
```


```{r}
population_Z006 <- orderMarkers(population_Z006, chr = 7, use.ripple = FALSE, map.function="kosambi")
plotRF(population_Z006, col.scheme = "redblue", mark.diagonal = TRUE)
```


```{r}
population_Z006 <- orderMarkers(population_Z006, chr = 8, use.ripple = FALSE, map.function="kosambi")
plotRF(population_Z006, col.scheme = "redblue", mark.diagonal = TRUE)
```


```{r}
population_Z006 <- orderMarkers(population_Z006, chr = 9, use.ripple = FALSE, map.function="kosambi")
plotRF(population_Z006, col.scheme = "redblue", mark.diagonal = TRUE)
```


```{r}
population_Z006 <- orderMarkers(population_Z006, chr = 10, use.ripple = FALSE, map.function="kosambi")
plotRF(population_Z006, col.scheme = "redblue", mark.diagonal = TRUE)
```

A partir do mapa de calor, parece ter um marcador extraviado porque algumas das frações de recombinação entre par de marcadores são ainda menores do que aquelas próximas à diagonal.

Vamos primeiro dar uma olhada na ordem atual. Para isso, usamos a função:pull.map

```{r}
pull.map(population_Z006, chr=1, as.table = TRUE)
pull.map(population_Z006, chr=2, as.table = TRUE)
pull.map(population_Z006, chr=3, as.table = TRUE)
pull.map(population_Z006, chr=4, as.table = TRUE)
pull.map(population_Z006, chr=5, as.table = TRUE)
pull.map(population_Z006, chr=6, as.table = TRUE)
pull.map(population_Z006, chr=7, as.table = TRUE)
pull.map(population_Z006, chr=8, as.table = TRUE)
pull.map(population_Z006, chr=9, as.table = TRUE)
pull.map(population_Z006, chr=10, as.table = TRUE)
```

Note que alguns marcadores parecem um pouco desligados, certo? Para verificar se eles estão em sua posição mais provável ou não, devemos comparar a probabilidade de log ("loglik") da ordem atual com as de ordens alternativas.

Então, primeiro, vamos ver qual é o loglik atual:

Olhar para a probabilidade de log atual ("loglik") é:

```{r}
attr(population_Z006$geno$`1`$map, "loglik")
attr(population_Z006$geno$`2`$map, "loglik")
attr(population_Z006$geno$`3`$map, "loglik")
attr(population_Z006$geno$`4`$map, "loglik")
attr(population_Z006$geno$`5`$map, "loglik")
attr(population_Z006$geno$`6`$map, "loglik")
attr(population_Z006$geno$`7`$map, "loglik")
attr(population_Z006$geno$`8`$map, "loglik")
attr(population_Z006$geno$`9`$map, "loglik")
attr(population_Z006$geno$`10`$map, "loglik")
```

Agora, vamos tentar algumas ordens alternativas. Primeiro, podemos usar para procurar inversões locais (o que parece ser o caso, por sinal):ripple = TRUE

```{r}
memory.limit(9999999999)
```

```{r}
population_Z006 <- orderMarkers(population_Z006, chr=1, use.ripple = TRUE, map.function="kosambi")
plotRF(population_Z006, mark.diagonal = TRUE, col.scheme = "redblue")
```

```{r}
population_Z006 <- orderMarkers(population_Z006, chr=2, use.ripple = TRUE, map.function="kosambi")
plotRF(population_Z006, mark.diagonal = TRUE, col.scheme = "redblue")
```

```{r}
population_Z006 <- orderMarkers(population_Z006, chr=3, use.ripple = TRUE, map.function="kosambi")
plotRF(population_Z006, mark.diagonal = TRUE, col.scheme = "redblue")
```

```{r}
population_Z006 <- orderMarkers(population_Z006, chr=4, use.ripple = TRUE, map.function="kosambi")
plotRF(population_Z006, mark.diagonal = TRUE, col.scheme = "redblue")
```

```{r}
population_Z006 <- orderMarkers(population_Z006, chr=5, use.ripple = TRUE, map.function="kosambi")
plotRF(population_Z006, mark.diagonal = TRUE, col.scheme = "redblue")
```

```{r}
population_Z006 <- orderMarkers(population_Z006, chr=6, use.ripple = TRUE, map.function="kosambi")
plotRF(population_Z006, mark.diagonal = TRUE, col.scheme = "redblue")
```

```{r}
population_Z006 <- orderMarkers(population_Z006, chr=7, use.ripple = TRUE, map.function="kosambi")
plotRF(population_Z006, mark.diagonal = TRUE, col.scheme = "redblue")
```

```{r}
population_Z006 <- orderMarkers(population_Z006, chr=8, use.ripple = TRUE, map.function="kosambi")
plotRF(population_Z006, mark.diagonal = TRUE, col.scheme = "redblue")
```

```{r}
population_Z006 <- orderMarkers(population_Z006, chr=9, use.ripple = TRUE, map.function="kosambi")
plotRF(population_Z006, mark.diagonal = TRUE, col.scheme = "redblue")
```

```{r}
population_Z006 <- orderMarkers(population_Z006, chr=10, use.ripple = TRUE, map.function="kosambi")
plotRF(population_Z006, mark.diagonal = TRUE, col.scheme = "redblue")
```

Novamente, parece ter um marcador extraviado porque algumas das frações de recombinação entre par de marcadores são ainda menores do que aquelas próximas à diagonal.

Vamos primeiro dar uma olhada na ordem atual. Para isso, usamos a função:pull.map

```{r}
pull.map(population_Z006, chr=1, as.table = TRUE)
pull.map(population_Z006, chr=2, as.table = TRUE)
pull.map(population_Z006, chr=3, as.table = TRUE)
pull.map(population_Z006, chr=4, as.table = TRUE)
pull.map(population_Z006, chr=5, as.table = TRUE)
pull.map(population_Z006, chr=6, as.table = TRUE)
pull.map(population_Z006, chr=7, as.table = TRUE)
pull.map(population_Z006, chr=8, as.table = TRUE)
pull.map(population_Z006, chr=9, as.table = TRUE)
pull.map(population_Z006, chr=10, as.table = TRUE)
```


```{r}
attr(population_Z006$geno$`1`$map, "loglik")
attr(population_Z006$geno$`2`$map, "loglik")
attr(population_Z006$geno$`3`$map, "loglik")
attr(population_Z006$geno$`4`$map, "loglik")
attr(population_Z006$geno$`5`$map, "loglik")
attr(population_Z006$geno$`6`$map, "loglik")
attr(population_Z006$geno$`7`$map, "loglik")
attr(population_Z006$geno$`8`$map, "loglik")
attr(population_Z006$geno$`9`$map, "loglik")
attr(population_Z006$geno$`10`$map, "loglik")
```


Legal! O grupo de ligação é menor e a probabilidade é maior do que a ordem anterior.

Finalmente, uma maneira de desenhar o mapa de linkage é usando a função:plotMap

```{r}
population_Z006 <- flip.order(population_Z006, chr = 1)
plotMap(population_Z006, show.marker.names=TRUE)
```


```{r}
population_Z006 <- flip.order(population_Z006, chr = 2)
plotMap(population_Z006, show.marker.names=TRUE)
```


```{r}
population_Z006 <- flip.order(population_Z006, chr = 3)
plotMap(population_Z006, show.marker.names=TRUE)
```


```{r}
population_Z006 <- flip.order(population_Z006, chr = 4)
plotMap(population_Z006, show.marker.names=TRUE)
```


```{r}
population_Z006 <- flip.order(population_Z006, chr = 5)
plotMap(population_Z006, show.marker.names=TRUE)
```


```{r}
population_Z006 <- flip.order(population_Z006, chr = 6)
plotMap(population_Z006, show.marker.names=TRUE)
```


```{r}
population_Z006 <- flip.order(population_Z006, chr = 7)
plotMap(population_Z006, show.marker.names=TRUE)
```


```{r}
population_Z006 <- flip.order(population_Z006, chr = 8)
plotMap(population_Z006, show.marker.names=TRUE)
```


```{r}
population_Z006 <- flip.order(population_Z006, chr = 9)
plotMap(population_Z006, show.marker.names=TRUE)
```


```{r}
population_Z006 <- flip.order(population_Z006, chr = 10)
plotMap(population_Z006, show.marker.names=TRUE)

```

Se quisermos ver onde os crossovers foram parar para os primeiros 10 indivíduos ao longo do mapa de linkage, então usamos a função:plotGeno

```{r}
plotGeno(population_Z006, chr = 1 , ind = 1:10)
```


```{r}
plotGeno(population_Z006, chr = 2 , ind = 1:10)
```


```{r}
plotGeno(population_Z006, chr = 3 , ind = 1:10)
```


```{r}
plotGeno(population_Z006, chr = 4 , ind = 1:10)
```


```{r}
plotGeno(population_Z006, chr = 5 , ind = 1:10)
```


```{r}
plotGeno(population_Z006, chr = 6 , ind = 1:10)
```


```{r}
plotGeno(population_Z006, chr = 7 , ind = 1:10)
```


```{r}
plotGeno(population_Z006, chr = 8 , ind = 1:10)
```


```{r}
plotGeno(population_Z006, chr = 9 , ind = 1:10)
```


```{r}
plotGeno(population_Z006, chr = 10 , ind = 1:10)
```
O azul × indicam que um crossover aconteceu nesse intervalo


```{r}
Map <- est.map(population_Z006, error.prob=0, map.function = "kosambi")
population_Z006 <- replace.map(population_Z006, Map)
```



#AULA 6
##Ordenando marcadores usando pacotes R/qtl e MDSmap+MAPpoly

```{r}
install.packages("mappoly")

library(mappoly)
```

